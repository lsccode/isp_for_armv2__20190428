//----------------------------------------------------------------------------
//   The confidential and proprietary information contained in this file may
//   only be used by a person authorised under and to the extent permitted
//   by a subsisting licensing agreement from ARM Limited or its affiliates.
//
//          (C) COPYRIGHT [2018] ARM Limited or its affiliates.
//              ALL RIGHTS RESERVED
//
//   This entire notice must be reproduced on all copies of this file
//   and copies of this file may only be made by a person if such person is
//   permitted to do so under the terms of a subsisting license agreement
//   from ARM Limited or its affiliates.
//----------------------------------------------------------------------------

/*
    Auto White Balance module:
        1. Plankian curve based
        2. Mesh lookup table based
        3. NBP decision tables

    Controls:
        AWB_SMOOTH_FILTER     - Enable smooth filter (fifo depth is FIFO_DEPTH)
        AWB_PRINT_DEBUG        - Enable test mode (with tracing debug information)
        AWB_TEST_DATA       - Runs test data through the system
        AWB_SIM_OLD_MESH    - Change probablities to simulation old awb mesh algorithm

    Default configuration:
        AWB_SMOOTH_FILTER - disable
        AWB_PRINT_DEBUG      - disable
        AWB_TEST_DATA     - disable
        AWB_SIM_OLD_MESH  - disable

    Sensor-depended DATA SECTION:    (TBD: DATA SECTION should be generated by the calibration tool)
        1. light_src
        2. rg_pos
        3. bg_pos
        4. rgbg_weight
        5. rgbg_ls_weight
        6. color_temp_mesh
        7. p_rg_low
        8. p_rg_high
        9. p_lux_low
        10. p_lux_high
        11. color_temp
        12. ct_rg_pos_calc
        13. ct_bg_pos_calc

    Structure of the module:
        1. Controls
        2. DATA SECTION (see $SENSOR_mesh_lookup.h)
        3. Routines
        4. AWB functions (calling order:  awb.scxml)


*/

#include "acamera_math.h"
#include "acamera_logger.h"
#include "awb_standard_api.h"
#include "awb_acamera_core.h"

//=============Controls===========================================================
#define AWB_SMOOTH_FILTER
//#define AWB_PRINT_DEBUG 90
//#define AWB_TEST_DATA
//================================================================================

#ifdef AWB_PRINT_DEBUG
#endif

//================================================================================


#ifdef LOG_MODULE
#undef LOG_MODULE
#define LOG_MODULE LOG_MODULE_AWB_ACAMERA
#endif


#define MAX_AWB_ZONES ( 33 * 33 )

typedef struct _awb_acamera_core_obj_ {
    uint8_t p_high;
    uint8_t p_low;
    uint8_t internal_inited;

    uint32_t rg_avg;
    uint32_t gb_avg;
    uint32_t stable_avg_RG;
    uint32_t stable_avg_BG;
    uint32_t avg_GR;
    uint32_t avg_GB;
    uint16_t rg_coef;
    uint16_t bg_coef;

    int32_t max_temp;
    int32_t min_temp;
    uint16_t max_temp_rg;
    uint16_t max_temp_bg;
    uint16_t min_temp_rg;
    uint16_t min_temp_bg;

    int32_t temperature_detected;
    uint8_t light_source_candidate;

    int32_t awb_warming_A[3];
    int32_t awb_warming_D75[3];
    int32_t awb_warming_D50[3];
    int32_t awb_warming[3];

    uint8_t mvalid[MAX_AWB_ZONES];
    uint8_t cwfzones[MAX_AWB_ZONES];
    uint8_t npcHigh[MAX_AWB_ZONES];
    uint8_t npcLow[MAX_AWB_ZONES];
    uint8_t sky_zones[MAX_AWB_ZONES];
    uint16_t rg_valid[MAX_AWB_ZONES];
    uint16_t bg_valid[MAX_AWB_ZONES];
    int32_t weight_[MAX_AWB_ZONES];
} awb_acamera_core_obj_t;

awb_acamera_core_obj_t awb_core_objs[FIRMWARE_CONTEXT_NUMBER];

//===========Routines=============================================================


/*------ LUTS fetchers -----------------*/

static uint16_t luts_fetch( uint16_t val, uint16_t min, uint16_t max, uint16_t step, const int16_t *data, uint16_t len )
{
    if ( step != 0 ) {
        if ( val < min )
            return data[0];
        if ( val > max )
            return data[len - 1];
        return data[( val - min ) / step]; // division by zero is checked
    } else {
        LOG( LOG_ERR, "AVOIDED DIVISION BY ZERO" );
        return val;
    }
}

static int16_t rglow_lut[] = {3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 26, 26, 27, 28, 29, 30, 31, 31, 32, 33, 34, 35, 36, 37, 38, 40, 41, 42, 43, 44, 45, 47, 48, 49, 51, 52, 53, 55, 56, 58, 60, 61, 63, 64, 66, 68, 70, 72, 73, 75, 77, 79, 81, 83, 86, 88, 90, 92, 95, 97, 99, 102, 104, 107, 110, 112, 115, 118, 121, 123, 126, 129, 133, 136, 139, 142, 145, 149, 152, 156, 159, 163, 167, 170, 174, 178, 182, 186, 190, 194, 199, 203, 207, 212, 216, 221, 226, 231, 235, 240, 245, 250, 253};
static int16_t rghigh_lut[] = {247, 242, 237, 233, 228, 223, 219, 215, 210, 206, 202, 198, 193, 189, 186, 182, 178, 174, 170, 167, 163, 160, 156, 153, 150, 147, 143, 140, 137, 134, 131, 128, 125, 123, 120, 117, 114, 112, 109, 107, 104, 102, 100, 97, 95, 93, 91, 89, 86, 84, 82, 80, 79, 77, 75, 73, 71, 69, 68, 66, 64, 63, 61, 60, 58, 57, 55, 54, 53, 51, 50, 49, 48, 46, 45, 44, 43, 42, 41, 40, 38, 37, 36, 36, 35, 34, 33, 32, 31, 30, 29, 29, 28, 27, 26, 26, 25, 24, 23, 23, 22, 22, 21, 20, 20, 19, 19, 18, 18, 17, 17, 16, 16, 15, 15, 14, 14, 14, 13, 13, 12, 12, 12, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4};
static int16_t luxlow_lut[] = {253, 251, 248, 243, 237, 229, 219, 207, 193, 179, 166, 154, 146, 141, 141, 146, 154, 166, 179, 193, 207, 219, 229, 237, 243, 248, 251, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 251, 242, 233, 224, 215, 207, 199, 191, 183, 175, 168, 161, 154, 147, 140, 134, 128, 122, 116, 110, 105, 100, 95, 90, 85, 81, 76, 72, 68, 65, 61, 57, 54, 51, 48, 45, 43, 40, 37, 35, 33, 31, 29, 27, 25, 24, 22, 21, 19, 18, 17, 15, 14, 13, 12, 11, 11, 10, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 4, 3, 3, 3};
static int16_t luxhigh_lut[] = {12, 12, 13, 14, 15, 16, 19, 24, 31, 41, 55, 72, 91, 110, 125, 134, 135, 128, 115, 99, 81, 65, 52, 42, 36, 33, 31, 31, 31, 32, 33, 34, 35, 36, 37, 39, 40, 41, 42, 44, 45, 46, 48, 49, 51, 53, 54, 56, 58, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 80, 82, 84, 87, 89, 92, 94, 97, 100, 103, 106, 108, 111, 115, 118, 121, 124, 128, 131, 135, 138, 142, 146, 150, 154, 158, 162, 166, 171, 175, 179, 184, 189, 194, 198, 203, 209, 214, 219, 225, 230, 236, 241, 247, 253};

static uint16_t luts_rg_low( uint16_t val )
{
    return luts_fetch( val, 168, 326, 1, rglow_lut, array_size( rglow_lut ) );
}

static uint16_t luts_rg_high( uint16_t val )
{
    return luts_fetch( val, 252, 419, 1, rghigh_lut, array_size( rghigh_lut ) );
}

static uint16_t luts_lux_low( uint16_t val )
{
    return luts_fetch( val, 88, 1483, 12, luxlow_lut, array_size( luxlow_lut ) );
}

static uint16_t luts_lux_high( uint16_t val )
{
    return luts_fetch( val, 1, 1650, 16, luxhigh_lut, array_size( luxhigh_lut ) );
}

/*------ LUTS fetchers END -------------*/


typedef struct interp_2d_point_t {
    uint16_t x, y;
    int32_t weight;
} interp_2d_point_t;

/*------ Smooth filter system ----------*/
#ifdef AWB_SMOOTH_FILTER

static void fifo_push( awb_acamera_core_obj_t *p_awb_core_obj, awb_calibration_data_t *p_cali_data, uint16_t rg, uint16_t gb )
{
    uint8_t awb_avg_coeff = p_cali_data->cali_awb_avg_coef[0];

    if ( awb_avg_coeff == 0 ) // no average
    {
        p_awb_core_obj->rg_avg = rg;
        p_awb_core_obj->gb_avg = gb;
    } else if ( p_awb_core_obj->rg_avg == 0 && p_awb_core_obj->gb_avg == 0 ) // initialization
    {
        p_awb_core_obj->rg_avg = (uint32_t)rg * awb_avg_coeff;
        p_awb_core_obj->gb_avg = (uint32_t)gb * awb_avg_coeff;
    } else // normal IIR filtration
    {
        p_awb_core_obj->rg_avg += rg - p_awb_core_obj->rg_avg / awb_avg_coeff; // division by zero is checked
        p_awb_core_obj->gb_avg += gb - p_awb_core_obj->gb_avg / awb_avg_coeff; // division by zero is checked
    }
}

static interp_2d_point_t get_point( awb_acamera_core_obj_t *p_awb_core_obj, awb_calibration_data_t *p_cali_data )
{
    uint8_t awb_avg_coeff = p_cali_data->cali_awb_avg_coef[0];
    interp_2d_point_t point;
    if ( awb_avg_coeff ) {
        point.x = ( uint16_t )( p_awb_core_obj->rg_avg / awb_avg_coeff ); // division by zero is checked
        point.y = ( uint16_t )( p_awb_core_obj->gb_avg / awb_avg_coeff ); // division by zero is checked
    } else {
        point.x = (uint16_t)p_awb_core_obj->rg_avg;
        point.y = (uint16_t)p_awb_core_obj->gb_avg;
    }
    point.weight = 0;
    return point;
}
#endif //AWB_SMOOTH_FILTER
/*----- Smooth filter system end ------*/

/*----- Mesh fetching functions -------*/

//linear interpolation
static int32_t interpl( int32_t x, int32_t x0, int32_t y0, int32_t x1, int32_t y1 )
{
    //return y0+(y1-y0)*(U16_MAX-x*x0)/(x*(x1-x0));
    if ( x1 == x0 )
        return y0;
    return y0 + ( ( ( y1 - y0 ) * ( x - x0 ) ) / ( x1 - x0 ) ); // division by zero is checked
}

//Get nearest points from lookup table based on (rg&bg) position
static interp_2d_point_t init_interp_2d_point( awb_calibration_data_t *p_cali_data, int32_t i, int32_t j, const int16_t *p_table, const int16_t *posx, const int16_t *posy )
{
    uint32_t x_case, y_case;
    interp_2d_point_t p;

    uint32_t lut_length = p_cali_data->cali_rg_pos_len;

    x_case = ( i <= 0 ) * 0 + ( ( i <= lut_length ) && ( i >= 0 ) ) + ( i > lut_length ) * 2;
    y_case = ( j <= 0 ) * 0 + ( ( j <= lut_length ) && ( j >= 0 ) ) + ( j > lut_length ) * 2;

    p.x = 0;
    p.y = 0;
    p.weight = 0;
    switch ( x_case ) {
    case 0:
        p.x = posx[0] - 20;
        i = 0;
        break;
    case 2:
        p.x = posx[lut_length - 1] + 20;
        i = lut_length - 1;
        break;
    default:
        p.x = posx[i];
        break;
    };

    switch ( y_case ) {
    case 0:
        p.y = posy[0] - 20;
        j = 0;
        break;
    case 2:
        p.y = posy[lut_length - 1] + 20;
        j = lut_length - 1;
        break;
    default:
        p.y = posy[j];
        break;
    };


    p.weight = p_table[j * lut_length + i];
    return p;
}


static int32_t get_index( awb_calibration_data_t *p_cali_data, int32_t v, const int16_t *p_lut )
{
    uint32_t lut_length = p_cali_data->cali_rg_pos_len;
    uint32_t indx = 0;
    int32_t i;
    for ( i = 1; i < lut_length; i++ ) {
        if ( v < p_lut[i] ) {
            indx = i - 1;
            return indx;
        }
    }
    indx = lut_length - 2;

    return indx;
}

//Get lookup value base on (rg&bg)
static int32_t AWB_mesh( awb_calibration_data_t *p_cali_data, uint32_t rg, uint32_t bg, int16_t *posx, int16_t *posy, const int16_t *p_table, uint8_t flag )
{
    int32_t weight = 0, db1, db2;
    int32_t x, y;
    interp_2d_point_t p00, p01, p10, p11;

    x = get_index( p_cali_data, rg, posx );
    y = get_index( p_cali_data, bg, posy );
    p00 = init_interp_2d_point( p_cali_data, x, y, p_table, posx, posy );
    p01 = init_interp_2d_point( p_cali_data, x + 1, y, p_table, posx, posy );
    p10 = init_interp_2d_point( p_cali_data, x, y + 1, p_table, posx, posy );
    p11 = init_interp_2d_point( p_cali_data, x + 1, y + 1, p_table, posx, posy );

    rg = ACAMERA_MAX( rg, p_cali_data->cali_rg_pos[0] );
    rg = ACAMERA_MIN( rg, p_cali_data->cali_rg_pos[p_cali_data->cali_rg_pos_len - 1] );
    bg = ACAMERA_MAX( bg, p_cali_data->cali_bg_pos[0] );
    bg = ACAMERA_MIN( bg, p_cali_data->cali_bg_pos[p_cali_data->cali_bg_pos_len - 1] );

    // NOTE: you changed these from rg/bg to irg/ibg
    db1 = interpl( rg, p00.x, p00.weight, p01.x, p01.weight );
    db2 = interpl( rg, p10.x, p10.weight, p11.x, p11.weight );

    weight = interpl( bg, p00.y, db1, p10.y, db2 );

    return weight;
}


// A min/max/step look up table version of init_interp_2d_point_LUT
static interp_2d_point_t init_interp_2d_point_LUT( awb_calibration_data_t *p_cali_data, int32_t i, int32_t j, int16_t minx, int16_t maxx, int16_t stepx, int16_t miny, int16_t maxy, int16_t stepy, const int16_t *p_table )
{
    uint32_t lut_length = p_cali_data->cali_rg_pos_len;

    interp_2d_point_t p;

    p.x = 0;
    p.y = 0;
    p.weight = 0;
    if ( i < 0 ) {
        i = 0;
        p.x = minx - 20;
    } else if ( i >= lut_length ) {
        i = lut_length - 1;
        p.x = maxx + 20;
    } else {
        p.x = minx + i * stepx;
    }
    if ( j < 0 ) {
        j = 0;
        p.y = miny - 20;
    } else if ( j >= lut_length ) {
        j = lut_length - 1;
        p.y = maxy + 20;
    } else {
        p.y = miny + j * stepy;
    }

    p.weight = p_table[j * lut_length + i];
    return p;
}

// A min/max/step look up table version of AWB_mesh
int32_t AWB_mesh_LUT( awb_calibration_data_t *p_cali_data, int32_t rg, int32_t bg, int16_t minx, int16_t maxx, int16_t stepx, int16_t miny, int16_t maxy, int16_t stepy, const int16_t *p_table )
{
    uint32_t lut_length = p_cali_data->cali_rg_pos_len;

    if ( ( stepx != 0 ) && ( stepy != 0 ) ) {
        int32_t weight, db1, db2;
        int32_t x, y;
        interp_2d_point_t p00, p01, p10, p11;
        interp_2d_point_t interp_2d_point;

        weight = 0;
        interp_2d_point.x = 0;
        interp_2d_point.y = 0;
        interp_2d_point.weight = 0;
        p00 = interp_2d_point;
        p01 = interp_2d_point;
        p10 = interp_2d_point;
        p11 = interp_2d_point;

        x = ( rg - minx ) / stepx; // division by zero is checked
        if ( x < 0 ) {
            x = 0;
            rg = minx;
        } else if ( x > lut_length - 1 ) {
            x = lut_length - 1;
            rg = maxx;
        }

        y = ( bg - miny ) / stepy; // division by zero is checked
        if ( y < 0 ) {
            y = 0;
            bg = miny;
        } else if ( y > lut_length - 1 ) {
            y = lut_length - 1;
            bg = maxy;
        }

        p00 = init_interp_2d_point_LUT( p_cali_data, x, y, minx, maxx, stepx, miny, maxy, stepy, p_table );
        p01 = init_interp_2d_point_LUT( p_cali_data, x + 1, y, minx, maxx, stepx, miny, maxy, stepy, p_table );
        p10 = init_interp_2d_point_LUT( p_cali_data, x, y + 1, minx, maxx, stepx, miny, maxy, stepy, p_table );
        p11 = init_interp_2d_point_LUT( p_cali_data, x + 1, y + 1, minx, maxx, stepx, miny, maxy, stepy, p_table );

        // NOTE: you changed these from rg/bg to irg/ibg
        db1 = interpl( rg, p00.x, p00.weight, p01.x, p01.weight );
        db2 = interpl( rg, p10.x, p10.weight, p11.x, p11.weight );

        weight = interpl( bg, p00.y, db1, p10.y, db2 );


        return weight;
    } else {
        LOG( LOG_ERR, "AVOIDED DIVISION BY ZERO" );
        return rg;
    }
}

// Get weight for additional source light (defined by light_src)
static int32_t mesh_AWB_getKnownSourceLight_weight_LUT( awb_calibration_data_t *p_cali_data, uint16_t rg, uint16_t bg, int32_t light_rg, int32_t light_bg )
{
    uint32_t lut_length = p_cali_data->cali_rg_pos_len;

    int32_t weight = 0;
    uint8_t valid_points;
    //Coordinated of possible distribution of KnownSourceLight
    int32_t MinX = light_rg - 30;
    int32_t MaxX = light_rg + 30;
    int32_t MinY = light_bg - 30;
    int32_t MaxY = light_bg + 30;

    valid_points = ( rg >= MinX ) && ( rg <= MaxX ) && ( bg >= MinY ) && ( bg <= MaxY );

    if ( valid_points ) {
        weight = AWB_mesh_LUT( p_cali_data, (int32_t)rg, (int32_t)bg, MinX, MaxX, ( MaxX - MinX ) / ( lut_length - 1 ), MinY, MaxY, ( MaxY - MinY ) / ( lut_length - 1 ), (int16_t *)p_cali_data->cali_mesh_ls_weight ); // division by zero is checked
    } else                                                                                                                                                                                                               //if out of range
    {
        weight = 0;
    }
    return weight;
}
//--- End mesh fetching functions -----
//================================================================================

#ifdef AWB_TEST_DATA
const uint16_t test_AVGrg = 167;
const uint16_t test_lux = 438;
const uint16_t rg_list[225] = {4095, 110, 113, 4095, 145, 146, 144, 130, 131, 135, 160, 154, 186, 225, 304, 4095, 112, 116, 115, 120, 147, 150, 140, 142, 142, 148, 144, 185, 202, 224, 4095, 110, 113, 112, 126, 142, 146, 143, 151, 161, 166, 170, 185, 195, 256, 144, 4095, 114, 116, 117, 142, 142, 134, 140, 167, 175, 189, 192, 187, 221, 118, 4095, 109, 111, 117, 138, 142, 135, 129, 166, 172, 208, 226, 186, 174, 128, 4095, 124, 114, 115, 134, 140, 134, 142, 170, 173, 211, 220, 190, 193, 144, 4095, 114, 116, 112, 130, 129, 140, 151, 168, 162, 182, 222, 193, 209, 4095, 4095, 110, 117, 114, 118, 124, 134, 149, 155, 136, 222, 232, 208, 218, 4095, 4095, 4095, 121, 110, 132, 146, 154, 141, 141, 144, 152, 154, 242, 237, 4095, 134, 136, 121, 112, 140, 198, 181, 152, 152, 151, 193, 151, 4095, 220, 4095, 4095, 4095, 4095, 180, 178, 189, 179, 165, 154, 200, 184, 212, 206, 219, 4095, 4095, 4095, 4095, 213, 192, 192, 185, 230, 197, 204, 179, 195, 206, 191, 4095, 4095, 208, 4095, 4095, 173, 177, 178, 189, 188, 186, 198, 195, 182, 188, 4095, 4095, 4095, 4095, 201, 4095, 4095, 185, 4095, 264, 206, 192, 191, 198, 198, 4095, 4095, 182, 4095, 4095, 4095, 165, 175, 4095, 4095, 171, 4095, 4095, 245, 233};
const uint16_t bg_list[225] = {4095, 375, 339, 4095, 316, 281, 269, 272, 284, 298, 270, 277, 260, 290, 304, 4095, 338, 337, 320, 312, 318, 284, 270, 266, 277, 299, 344, 259, 258, 298, 4095, 409, 358, 446, 321, 313, 297, 286, 285, 282, 295, 298, 267, 255, 238, 4095, 4095, 363, 390, 374, 306, 317, 344, 309, 299, 286, 272, 257, 243, 243, 832, 4095, 498, 433, 429, 319, 329, 403, 333, 318, 308, 267, 237, 237, 244, 512, 4095, 265, 349, 342, 316, 345, 383, 327, 314, 311, 262, 247, 254, 254, 4095, 4095, 326, 349, 392, 327, 376, 318, 332, 320, 317, 280, 233, 259, 248, 4095, 4095, 425, 362, 338, 408, 436, 313, 320, 325, 302, 244, 237, 257, 245, 4095, 4095, 4095, 335, 315, 404, 325, 326, 393, 348, 307, 271, 261, 244, 242, 4095, 348, 4095, 327, 322, 317, 252, 323, 324, 328, 273, 279, 282, 4095, 263, 4095, 4095, 4095, 4095, 284, 296, 285, 305, 311, 310, 266, 294, 268, 245, 243, 4095, 4095, 4095, 4095, 254, 280, 280, 296, 253, 306, 264, 306, 282, 269, 268, 4095, 4095, 4095, 4095, 4095, 287, 293, 294, 279, 281, 292, 274, 278, 291, 277, 4095, 4095, 4095, 4095, 281, 4095, 4095, 278, 4095, 236, 258, 274, 273, 260, 251, 4095, 4095, 285, 4095, 4095, 4095, 297, 297, 4095, 4095, 296, 4095, 4095, 368, 228};
const uint16_t awbsum_list[225] = {1, 352, 361, 1, 5774, 9345, 22368, 24103, 28465, 27352, 6645, 15524, 652, 127, 19, 0, 6072, 5418, 180, 2535, 32656, 14015, 13889, 12827, 32380, 44656, 32587, 6042, 1839, 56, 0, 179, 6124, 1394, 3296, 36653, 20349, 20385, 20463, 45124, 59282, 58005, 23631, 10450, 29481, 9, 2, 1932, 5840, 10512, 31342, 26509, 24189, 24071, 52358, 13509, 36016, 25666, 50435, 60401, 52, 0, 436, 5981, 7549, 36088, 24665, 38383, 22573, 49044, 44443, 50278, 16500, 38153, 45546, 32, 2, 598, 8199, 727, 31626, 21719, 36816, 46929, 31411, 41719, 56808, 21441, 37951, 33373, 27, 0, 5646, 11987, 98, 33632, 22246, 16415, 56141, 56533, 22521, 46428, 24779, 35069, 32814, 0, 0, 319, 21238, 2433, 5163, 5817, 14381, 14709, 20957, 9165, 37020, 31565, 34387, 44714, 0, 0, 0, 30161, 2070, 1567, 2790, 3670, 2583, 6641, 11503, 11098, 3504, 12762, 37567, 3, 109, 17, 5486, 1249, 2065, 14798, 1273, 6585, 8755, 7848, 5043, 406, 0, 1253, 0, 0, 0, 0, 18840, 37829, 31884, 17410, 27019, 1613, 8075, 20028, 7240, 8755, 7148, 0, 0, 2, 0, 11188, 52206, 29874, 48571, 9642, 518, 8479, 28332, 31490, 19921, 5540, 0, 0, 13, 4, 0, 2102, 13519, 23928, 22225, 15966, 18273, 41638, 37871, 38643, 45642, 0, 1, 7, 6, 88, 5, 0, 244, 0,
                                   281, 6277, 18480, 28732, 40855, 28454, 0, 0, 285, 9, 0, 3, 279, 372, 1, 1, 816, 0, 0, 46, 614};
#endif


//Get average (rg&bg)
static void awb_calc_avg_weighted_gr_gb_mesh( awb_acamera_core_obj_t *p_awb_core_obj, awb_stats_data_t *stats, awb_input_data_t *input )
{
    uint64_t sum = 0;
    uint32_t npcH = 0;
    uint32_t npcL = 0;
    uint32_t npcLsum = 0;
    uint32_t npcHsum = 0;

    uint64_t avg_RG = 0;
    uint64_t avg_BG = 0;
    uint64_t GRres = 0;
    uint64_t GBres = 0;
    int32_t temp_cal = 0;
    int32_t store = 0;
    int32_t MinX = 0;
    int32_t MinY = 0;
    int32_t MaxX = 0;
    int32_t MaxY = 0;

    int32_t weight = 0;
    int32_t weight_ls = 0;
    int32_t *weight_ = p_awb_core_obj->weight_;
    uint16_t _i = 0;
    uint16_t _j = 0;
    uint16_t npccount = 0;
    uint16_t lux = 0;
    uint16_t rg = 0;
    uint16_t bg = 0;
    uint16_t p_rg_highTemp = 0;
    uint16_t p_rg_lowTemp = 0;
    uint16_t p_lux_lowTemp = 0;
    uint16_t p_lux_highTemp = 0;
    uint16_t sky_cut_high = 0;
    uint16_t sky_cut_low = 0;
    uint16_t sky_cut_high_bg = 0;
    uint16_t *rg_valid = p_awb_core_obj->rg_valid;
    uint16_t *bg_valid = p_awb_core_obj->bg_valid;
    uint8_t *mvalid = p_awb_core_obj->mvalid;
    uint8_t *cwfzones = p_awb_core_obj->cwfzones;
    uint8_t *npcHigh = p_awb_core_obj->npcHigh;
    uint8_t *npcLow = p_awb_core_obj->npcLow;
    uint8_t *sky_zones = p_awb_core_obj->sky_zones;
    uint8_t npcHmean = 0;
    uint8_t npcLmean = 0;
    uint8_t valid_zone = 0;
    uint8_t clipRG = 0;
    uint8_t clipBG = 0;

    uint8_t p_highTemp = 50;
    uint8_t p_lowTemp = 50;
    uint8_t adjust_sky = 0;

    awb_acamera_input_t *p_acamera_input = (awb_acamera_input_t *)input->acamera_input;
    awb_calibration_data_t *p_cali_data = &( p_acamera_input->cali_data );
    unsigned short( *_calibration_light_src )[2] = p_cali_data->cali_light_src;

    if ( !p_awb_core_obj->internal_inited ) {

        p_awb_core_obj->internal_inited = 1;

        // Set the min/max temperatures and their gains:
        if ( ( p_cali_data->cali_color_temp[0] != 0 ) &&
             ( p_cali_data->cali_color_temp[p_cali_data->cali_color_temp_len - 1] != 0 ) &&
             ( p_cali_data->cali_ct_rg_pos_calc[0] != 0 ) &&
             ( p_cali_data->cali_ct_bg_pos_calc[0] != 0 ) &&
             ( p_cali_data->cali_ct_rg_pos_calc[p_cali_data->cali_ct_rg_pos_calc_len - 1] != 0 ) &&
             ( p_cali_data->cali_ct_bg_pos_calc[p_cali_data->cali_ct_bg_pos_calc_len - 1] != 0 ) ) {
            p_awb_core_obj->min_temp = 1000000 / p_cali_data->cali_color_temp[p_cali_data->cali_color_temp_len - 1];            // division by zero is checked
            p_awb_core_obj->max_temp = 1000000 / p_cali_data->cali_color_temp[0];                                               // division by zero is checked
            p_awb_core_obj->max_temp_rg = U16_MAX / p_cali_data->cali_ct_rg_pos_calc[0];                                        // division by zero is checked
            p_awb_core_obj->max_temp_bg = U16_MAX / p_cali_data->cali_ct_bg_pos_calc[0];                                        // division by zero is checked
            p_awb_core_obj->min_temp_rg = U16_MAX / p_cali_data->cali_ct_rg_pos_calc[p_cali_data->cali_ct_rg_pos_calc_len - 1]; // division by zero is checked
            p_awb_core_obj->min_temp_bg = U16_MAX / p_cali_data->cali_ct_bg_pos_calc[p_cali_data->cali_ct_bg_pos_calc_len - 1]; // division by zero is checked
        } else {
            LOG( LOG_ERR, "AVOIDED DIVISION BY ZERO" );
        }
    }

#ifdef AWB_PRINT_DEBUG
    static uint16_t ittcount = 0;
    const uint16_t debugprintperiod = AWB_PRINT_DEBUG;
    ittcount++;
    if ( ittcount > debugprintperiod )
        ittcount = 0;
#endif
    //
    // - Initialisation
    //

    for ( _i = 0; _i < stats->zones_size; ++_i ) {
        weight_[_i] = 0;
        mvalid[_i] = 0;
        cwfzones[_i] = 0;
        sky_zones[_i] = 1;
        npcHigh[_i] = npcLow[_i] = 0;
    }

//
// - Get lux
//

#ifdef AWB_TEST_DATA
    for ( _i = 0; _i < stats->zones_size; ++_i ) {
        stats->awb_zones[_i].rg = U16_MAX / rg_list[_i];
        stats->awb_zones[_i].bg = U16_MAX / bg_list[_i];
        stats->awb_zones[_i].sum = awbsum_list[_i];
    }
    lux = test_lux;
#else
    // EV to lux LUT:
    if ( p_acamera_input->misc_info.cur_exposure_log2 < p_cali_data->cali_evtolux_ev_lut[0] ) {
        lux = p_cali_data->cali_evtolux_lux_lut[0];
    } else if ( p_acamera_input->misc_info.cur_exposure_log2 >= p_cali_data->cali_evtolux_ev_lut[p_cali_data->cali_evtolux_ev_lut_len - 1] ) {
        lux = p_cali_data->cali_evtolux_lux_lut[p_cali_data->cali_evtolux_lux_lut_len - 1];
    } else {
        for ( _i = 1; _i < p_cali_data->cali_evtolux_ev_lut_len; _i++ ) {
            if ( p_acamera_input->misc_info.cur_exposure_log2 < p_cali_data->cali_evtolux_ev_lut[_i] )
                break;
        }
        lux = interpl( p_acamera_input->misc_info.cur_exposure_log2, p_cali_data->cali_evtolux_ev_lut[_i - 1], p_cali_data->cali_evtolux_lux_lut[_i - 1], p_cali_data->cali_evtolux_ev_lut[_i], p_cali_data->cali_evtolux_lux_lut[_i] );
    }
#endif


    //
    // - Calculate probabilities from tables
    //

    if ( lux > 5000 ) {
        p_lux_highTemp = 99;
        p_lux_lowTemp = 1;
    } else {
        p_lux_highTemp = luts_lux_high( lux );
        p_lux_lowTemp = luts_lux_low( lux );
    }

#ifdef AWB_PRINT_DEBUG
    if ( ittcount == debugprintperiod )
        LOG( LOG_DEBUG, "EV = %ld LUT_lux = %04x p_lux_highTemp = %04x p_lux_lowTemp = %04x \n", p_acamera_input->misc_info.cur_exposure_log2, lux, p_lux_highTemp, p_lux_lowTemp );
#endif

    //======================================================
    // - Light Corner Points
    //======================================================

    MinX = ACAMERA_MIN( p_cali_data->cali_rg_pos[0], _calibration_light_src[0][0] );
    MinY = ACAMERA_MIN( p_cali_data->cali_bg_pos[0], _calibration_light_src[0][1] );

    MaxX = ACAMERA_MAX( p_cali_data->cali_rg_pos[p_cali_data->cali_rg_pos_len - 1], _calibration_light_src[0][0] );
    MaxY = ACAMERA_MAX( p_cali_data->cali_bg_pos[p_cali_data->cali_bg_pos_len - 1], _calibration_light_src[0][1] );

    for ( _i = 1; _i < p_acamera_input->cali_data.cali_light_src_len; _i++ ) {
        if ( _calibration_light_src[_i][0] < MinX )
            MinX = _calibration_light_src[_i][0];
        if ( _calibration_light_src[_i][1] < MinY )
            MinY = _calibration_light_src[_i][1];
        if ( _calibration_light_src[_i][0] > MaxX )
            MaxX = _calibration_light_src[_i][0];
        if ( _calibration_light_src[_i][1] > MaxY )
            MaxY = _calibration_light_src[_i][1];
    }

    //
    // - Main loop:
    //
    npccount = 0;
    npcLsum = npcHsum = 0;

    for ( _i = 0; _i < stats->zones_size; _i++ ) {
        rg = stats->awb_zones[_i].rg;
        bg = stats->awb_zones[_i].bg;

        // See if we're within the validity rectangle
        clipRG = ( ( rg >= MinX ) && ( rg <= MaxX ) );
        clipBG = ( ( bg >= MinY ) && ( bg <= MaxY ) );
        valid_zone = ( clipRG && clipBG && ( stats->awb_zones[_i].sum > 256 ) );
        mvalid[_i] = valid_zone;

        if ( valid_zone ) {

            weight = AWB_mesh( p_cali_data, (uint32_t)rg, (uint32_t)bg, (int16_t *)p_cali_data->cali_rg_pos, (int16_t *)p_cali_data->cali_bg_pos, (int16_t *)p_cali_data->cali_mesh_rgbg_weight, 0 );

            // Extra light source probabilities
            for ( _j = 0; _j < p_acamera_input->cali_data.cali_light_src_len; _j++ ) {
                weight_ls = mesh_AWB_getKnownSourceLight_weight_LUT( p_cali_data, rg, bg, _calibration_light_src[_j][0], _calibration_light_src[_j][1] );
                // +15 to stop false positives
                if ( ( weight_ls >= 20 ) && ( weight_ls > ( weight + 15 ) ) ) {
                    weight = weight_ls;
                    if ( _j == 0 )
                        cwfzones[_i] = 1;
                }
            }
            weight = ACAMERA_MAX( weight, 0 );
            if ( weight < 60 ) {
                // insignificant weight (Err_TOLERANCE_2)
                weight = 0;
                mvalid[_i] = 0;
            } else {
                // significant weight
                weight_[_i] = weight;

                p_rg_highTemp = luts_rg_high( rg );
                p_rg_lowTemp = luts_rg_low( rg );


                npcH = p_highTemp * p_rg_highTemp * p_lux_highTemp;
                npcL = p_lowTemp * p_rg_lowTemp * p_lux_lowTemp;
                store = npcH + npcL;
                if ( store != 0 ) {
                    npcHigh[_i] = ( 100 * npcH ) / store; // division by zero is checked
                    npcLow[_i] = ( 100 * npcL ) / store;  // division by zero is checked
                } else {
                    npcHigh[_i] = ( 100 * npcH );
                    npcLow[_i] = ( 100 * npcL );
                    LOG( LOG_ERR, "AVOIDED DIVISION BY ZERO" );
                }
                npcHsum += npcHigh[_i];
                npcLsum += npcLow[_i];
                npccount++;
            } // end significant weight

        } // end valid_zone

    } // end main loop


    //
    // - NBP decision
    //

    if ( npccount > 0 ) {
        npcHmean = npcHsum / npccount; // division by zero is checked
        npcLmean = npcLsum / npccount; // division by zero is checked
    } else {
        // No strong zones, allow the calculation to fail to last known
        // with the code below
        npcHmean = 50;
        npcLmean = 50;
    }

    uint8_t evtolux_probability_enable = p_cali_data->cali_evtolux_probability_enable[0];
    if ( evtolux_probability_enable == 0 ) {
        npcHmean = 50;
        npcLmean = 50;
        lux = 500;
    }

    p_awb_core_obj->p_high = npcHmean;
    p_awb_core_obj->p_low = npcLmean;

    uint32_t enable_awb_mix_light = p_cali_data->cali_awb_mix_light_param[0];
    uint32_t lux_low = p_cali_data->cali_awb_mix_light_param[1];
    uint32_t lux_high = p_cali_data->cali_awb_mix_light_param[2];
    uint32_t contrast_threshold = p_cali_data->cali_awb_mix_light_param[3];
    uint32_t bg_threshold = p_cali_data->cali_awb_mix_light_param[4];
    uint32_t bg_weight = p_cali_data->cali_awb_mix_light_param[5];
    uint32_t rgHigh_LUT_max = p_cali_data->cali_awb_mix_light_param[6];
    uint32_t rgHigh_LUT_min = p_cali_data->cali_awb_mix_light_param[7];
    uint32_t print_debug = p_cali_data->cali_awb_mix_light_param[8];
    uint16_t rg_weight = 0;

    if ( print_debug )
        LOG( LOG_NOTICE, "lux: %d, contrast from Iridix: %u", lux, (unsigned int)p_acamera_input->misc_info.iridix_contrast );

    if ( enable_awb_mix_light && lux > lux_low && lux < lux_high && p_acamera_input->misc_info.iridix_contrast > contrast_threshold ) {

        if ( print_debug )
            LOG( LOG_NOTICE, "mix light" );

        for ( _i = 0; _i < stats->zones_size; _i++ ) {
            rg = stats->awb_zones[_i].rg;

            rg_weight = luts_fetch( rg, rgHigh_LUT_min, rgHigh_LUT_max, 1, (int16_t *)rghigh_lut, array_size( rghigh_lut ) );
            rg_weight = ( 100 * rg_weight ) / rghigh_lut[0];

            weight_[_i] = ( mvalid[_i] ? ( weight_[_i] * rg_weight ) : 0 );

            bg = stats->awb_zones[_i].bg;
            if ( bg > bg_threshold ) {
                weight_[_i] = ( mvalid[_i] ? bg_weight : 0 );

                if ( print_debug )
                    LOG( LOG_NOTICE, "remove bg" );
            }
        }
    } else if ( ( ( npcHmean >= npcLmean ) && ( npcHmean - npcLmean < 15 ) ) || ( ( npcHmean < npcLmean ) && ( npcLmean - npcHmean < 15 ) ) ) {
        // Case : probabilities are about the same
        if ( lux < 10 ) {
            // Low light

            for ( _i = 0; _i < stats->zones_size; _i++ ) {
                if ( mvalid[_i] && stats->awb_zones[_i].rg >= p_cali_data->cali_ct_rg_pos_calc[p_cali_data->cali_ct65pos[0]] && stats->awb_zones[_i].bg <= p_cali_data->cali_ct_bg_pos_calc[p_cali_data->cali_ct65pos[0]] ) { // division by zero is checked
                    weight_[_i] = weight_[_i] * npcLow[_i];
                } else {
                    weight_[_i] = 0;
                }
            }
        } else {
            // Not bright or dark
            for ( _i = 0; _i < stats->zones_size; _i++ ) {
                weight_[_i] = ( mvalid[_i] ? 100 * weight_[_i] : 0 );
            }
        }
    } else if ( npcLmean > npcHmean ) {
        // likely we're in a dark situation
        for ( _i = 0; _i < stats->zones_size; _i++ ) {
            weight_[_i] = ( mvalid[_i] ? weight_[_i] * npcLow[_i] : 0 );
        }
    } else {
        // likely we're in a light situation

        if ( lux > p_cali_data->cali_sky_lux_th[0] ) {
            adjust_sky = 1;
        }

        avg_BG = 0;
        for ( _i = 0; _i < stats->zones_size; _i++ ) {
            avg_BG += stats->awb_zones[_i].bg;
        }
        if ( stats->zones_size )
            avg_BG /= stats->zones_size; // division by zero is checked

        if ( lux > p_cali_data->cali_sky_lux_th[0] && avg_BG > 246 ) {
            // looks like a sky scene
            sky_cut_high = p_cali_data->cali_ct_rg_pos_calc[p_cali_data->cali_ct65pos[0]];

            for ( _j = 25; _j <= 65; _j += 20 ) {
                // NOTE : these are flip rt to matlab to save on vaariables
                sky_cut_low = ( ( 950 + _j ) * ( ( p_cali_data->cali_ct_rg_pos_calc[p_cali_data->cali_ct40pos[0]] + 256 ) >> 1 ) ) / 1000; // division by zero is checked

                sky_cut_high_bg = ( 950 + _j > 1000 ? p_cali_data->cali_ct_bg_pos_calc[p_cali_data->cali_ct65pos[0]] : ( ( 950 + _j ) * p_cali_data->cali_ct_bg_pos_calc[p_cali_data->cali_ct65pos[0]] ) / 1000 ); // division by zero is checked

                sum = 0;
                for ( _i = 0; _i < stats->zones_size; _i++ ) {
                    if ( ( stats->awb_zones[_i].rg >= sky_cut_high ) && ( stats->awb_zones[_i].rg <= sky_cut_low ) && ( stats->awb_zones[_i].bg <= sky_cut_high_bg ) ) { // division by zero is checked
                        sky_zones[_i] = 1;
                    } else {
                        sky_zones[_i] = 0;
                    }
                    store = weight_[_i] * mvalid[_i] * npcHigh[_i] * sky_zones[_i];
                    sum += store;
                }
                if ( sum != 0 ) {
                    break;
                }
            }
            for ( _i = 0; _i < stats->zones_size; _i++ ) {
                weight_[_i] = weight_[_i] * mvalid[_i] * npcHigh[_i] * sky_zones[_i];
            }

        } else {
            // general bright scene
            for ( _i = 0; _i < stats->zones_size; _i++ ) {
                weight_[_i] = ( mvalid[_i] ? weight_[_i] * npcHigh[_i] : 0 );
            }
        }
    }

    //
    // - CWF
    //

    sum = 0;
    for ( _i = 0; _i < stats->zones_size; _i++ )
        sum += cwfzones[_i];
    // strictly less-than to combat integer rounding
    if ( sum > ( stats->zones_size >> 3 ) && npcLmean > npcHmean && lux > 100 && lux <= 900 ) {
        // lots of CWF zones - keep CWF zones
        for ( _i = 0; _i < stats->zones_size; _i++ ) {
            rg_valid[_i] = stats->awb_zones[_i].rg * mvalid[_i] * cwfzones[_i]; // division by zero is checked
            bg_valid[_i] = stats->awb_zones[_i].bg * mvalid[_i] * cwfzones[_i]; // division by zero is checked
            weight_[_i] = weight_[_i] * cwfzones[_i];
        }
    } else if ( sum >= 1 && lux > 900 ) {
        // A few CWF zones - keep non-CWF zones
        for ( _i = 0; _i < stats->zones_size; _i++ ) {
            {
                rg_valid[_i] = stats->awb_zones[_i].rg * mvalid[_i] * ( 1 - cwfzones[_i] ) * sky_zones[_i]; // division by zero is checked
                bg_valid[_i] = stats->awb_zones[_i].bg * mvalid[_i] * ( 1 - cwfzones[_i] ) * sky_zones[_i]; // division by zero is checked
                weight_[_i] = weight_[_i] * ( 1 - cwfzones[_i] );
            }
        }
    } else {
        // Definately not CWF
        for ( _i = 0; _i < stats->zones_size; _i++ ) {


            rg_valid[_i] = stats->awb_zones[_i].rg * mvalid[_i] * sky_zones[_i]; // division by zero is checked
            bg_valid[_i] = stats->awb_zones[_i].bg * mvalid[_i] * sky_zones[_i]; // division by zero is checked
        }
    }

    //
    // - norm_p checks
    //
    sum = 0;
    for ( _i = 0; _i < stats->zones_size; _i++ )
        sum += weight_[_i];

#ifdef AWB_PRINT_DEBUG
    if ( ittcount == debugprintperiod )
        LOG( LOG_DEBUG, "Final weight sum = %08lx\n", sum );
#endif

    if ( sum == 0 ) {
        // no valid zones
        avg_RG = 0;
        for ( _i = 0; _i < stats->zones_size; _i++ ) {
            avg_RG += stats->awb_zones[_i].rg;
        }
        if ( stats->zones_size )
            avg_RG /= stats->zones_size; // division by zero is checked

        if ( avg_RG > p_cali_data->cali_ct_rg_pos_calc[p_cali_data->cali_ct30pos[0]] ) { // division by zero is checked
            avg_RG = p_cali_data->cali_ct_rg_pos_calc[p_cali_data->cali_ct30pos[0]];
            avg_BG = p_cali_data->cali_ct_bg_pos_calc[p_cali_data->cali_ct30pos[0]];

        } else {
            avg_RG = 256; //p_awb_core_obj->stable_avg_RG;
            avg_BG = 256; //p_awb_core_obj->stable_avg_BG;
        }
    } else {
        // at least some valid zones
        avg_BG = avg_RG = 0;
        for ( _i = 0; _i < stats->zones_size; _i++ ) {
            avg_RG += (uint64_t)rg_valid[_i] * weight_[_i];
            avg_BG += (uint64_t)bg_valid[_i] * weight_[_i];
        }
        if ( sum ) {
            avg_BG /= sum; // division by zero is checked
            avg_RG /= sum; // division by zero is checked
        }

        //To Store the last stable Light Source.
        p_awb_core_obj->stable_avg_BG = avg_BG;
        p_awb_core_obj->stable_avg_RG = avg_RG;
    }

    //
    // - adjust sky
    //
    if ( adjust_sky && p_cali_data->cali_wb_strength[2] ) {
        avg_RG = ( p_cali_data->cali_wb_strength[0] * avg_RG ) / p_cali_data->cali_wb_strength[2]; // division by zero is checked
        avg_BG = ( p_cali_data->cali_wb_strength[1] * avg_BG ) / p_cali_data->cali_wb_strength[2]; // division by zero is checked
    }
    // if we have no clue what to do - do nothing!!!
    avg_RG = ( avg_RG ? avg_RG : p_awb_core_obj->stable_avg_RG );
    avg_BG = ( avg_BG ? avg_BG : p_awb_core_obj->stable_avg_BG );

#if AWB_BG_MAX_GAIN
    // Clip maxium gains for rg and bg according to gain
    int16_t max_bg_gain = acamera_calc_modulation_u16( p_acamera_input->misc_info.log2_gain, p_cali_data->cali_awb_bg_max_gain, p_cali_data->cali_awb_bg_max_gain_len );

    if ( avg_BG < max_bg_gain ) {
        avg_BG = max_bg_gain;
    }
#endif

    if ( avg_RG && avg_BG ) {
        GRres = U16_MAX / avg_RG; // division by zero is checked
        GBres = U16_MAX / avg_BG; // division by zero is checked
    } else {
        LOG( LOG_ERR, "AVOIDED DIVISION BY ZERO" );
    }

#ifdef AWB_SMOOTH_FILTER
    interp_2d_point_t point;
    fifo_push( p_awb_core_obj, p_cali_data, GRres, GBres );
    point = get_point( p_awb_core_obj, p_cali_data );
    p_awb_core_obj->avg_GR = point.x;
    p_awb_core_obj->avg_GB = point.y;


#else
    p_awb_core_obj->avg_GR = GRres;
    p_awb_core_obj->avg_GB = GBres;
#endif


#ifdef AWB_PRINT_DEBUG
    clipRG = 0;
#endif

    if ( !p_acamera_input->misc_info.global_manual_awb ) {

        // Only set the values if we're not in manual mode
        if ( p_awb_core_obj->avg_GR && p_awb_core_obj->avg_GB ) {

            temp_cal = AWB_mesh( p_cali_data, ( uint32_t )( U16_MAX / p_awb_core_obj->avg_GR ), ( uint32_t )( U16_MAX / p_awb_core_obj->avg_GB ), (int16_t *)p_cali_data->cali_rg_pos, (int16_t *)p_cali_data->cali_bg_pos, (int16_t *)p_cali_data->cali_mesh_color_temperature, 1 ); // division by zero is checked
            if ( temp_cal )
                temp_cal = 1000000 / temp_cal; // division by zero is checked

            if ( temp_cal < p_awb_core_obj->min_temp ) {
#ifdef AWB_PRINT_DEBUG
                clipRG = 1;
#endif
                temp_cal = p_awb_core_obj->min_temp;
                p_awb_core_obj->rg_coef = p_awb_core_obj->min_temp_rg;
                p_awb_core_obj->bg_coef = p_awb_core_obj->min_temp_bg;

            } else if ( temp_cal > p_awb_core_obj->max_temp ) {
#ifdef AWB_PRINT_DEBUG
                clipRG = 2;
#endif
                temp_cal = p_awb_core_obj->max_temp;
                p_awb_core_obj->rg_coef = p_awb_core_obj->max_temp_rg;
                p_awb_core_obj->bg_coef = p_awb_core_obj->max_temp_bg;

            } else {
                p_awb_core_obj->rg_coef = p_awb_core_obj->avg_GR;
                p_awb_core_obj->bg_coef = p_awb_core_obj->avg_GB;
            }
        }
    } else {

        temp_cal = AWB_mesh( p_cali_data, ( uint32_t )( p_awb_core_obj->rg_coef ? U16_MAX / p_awb_core_obj->rg_coef : U16_MAX ), ( uint32_t )( p_awb_core_obj->bg_coef ? U16_MAX / p_awb_core_obj->bg_coef : U16_MAX ), (int16_t *)p_cali_data->cali_rg_pos, (int16_t *)p_cali_data->cali_bg_pos, (int16_t *)p_cali_data->cali_mesh_color_temperature, 1 ); // division by zero is checked
        if ( temp_cal )
            temp_cal = 1000000 / temp_cal; // division by zero is checked

        // moved from awb_normalise() func: update rg/bg coef in manual mode for next frame calculation
        p_awb_core_obj->rg_coef = p_acamera_input->misc_info.global_awb_red_gain;
        p_awb_core_obj->bg_coef = p_acamera_input->misc_info.global_awb_blue_gain;
    }

    p_awb_core_obj->temperature_detected = temp_cal;

    if ( print_debug )
        LOG( LOG_INFO, "lux %d plow %d phigh %d temp_cal %d rg_coef %d bg_coef %d\n", (int)lux, (int)npcLmean, (int)npcHmean, (int)temp_cal, (int)p_awb_core_obj->rg_coef, (int)p_awb_core_obj->bg_coef );

#ifdef AWB_PRINT_DEBUG
    if ( ittcount == debugprintperiod )
        LOG( LOG_DEBUG, "PLow = %02x PHigh = %02x Manual = %02x Clipped = %02x rg_coef = %08x bg_coef = %08x temp_cal = %ld\n", npcLmean, npcHmean, p_acamera_input->misc_info.global_manual_awb, clipRG, p_awb_core_obj->rg_coef, p_awb_core_obj->bg_coef, temp_cal );
#endif
}

//    For CCM switching
static void awb_detect_light_source( awb_acamera_core_obj_t *p_awb_core_obj )
{
    p_awb_core_obj->light_source_candidate = AWB_LIGHT_SOURCE_A;
    if ( p_awb_core_obj->temperature_detected <= AWB_DLS_LIGHT_SOURCE_A_D40_BORDER ) {
        p_awb_core_obj->light_source_candidate = AWB_LIGHT_SOURCE_A;
    } else if ( p_awb_core_obj->temperature_detected <= AWB_DLS_LIGHT_SOURCE_D40_D50_BORDER ) {
        p_awb_core_obj->light_source_candidate = AWB_LIGHT_SOURCE_D40;
    } else {
        p_awb_core_obj->light_source_candidate = AWB_LIGHT_SOURCE_D50;
    }
}

static void awb_calculate_warming_effect( awb_acamera_core_obj_t *p_awb_core_obj, awb_calibration_data_t *p_cali_data )
{
    /*  
        This function drives the cooling warming effect according to colour temperature.
        See kruithof curve for a reference and background theory about this functionality
        Tuning luts default
        CALIBRATION_AWB_WARMING_LS_A = {256,256,256}; //u4.8
        CALIBRATION_AWB_WARMING_LS_D50= {256,256,256};//u4.8
        CALIBRATION_AWB_WARMING_LS_D75= {256,256,256};//u4.8
        AWB_colour_preference={7500,6000,4700,2800};// in Kelvin

        | blue gain
        |    .                    .    .
        |        .            .
        |            . .  . .
        |        .              .
        |Red. gain                        .
        |.                            .
        -----|------|------|--------|-------
            70000  6000    4700     2800    CCT in kelvin
    */

    int32_t temperature = p_awb_core_obj->temperature_detected;
    p_awb_core_obj->awb_warming_A[0] = ( int32_t )( p_cali_data->cali_awb_warming_ls_a[0] ) << 8;
    p_awb_core_obj->awb_warming_A[1] = ( int32_t )( p_cali_data->cali_awb_warming_ls_a[1] ) << 8;
    p_awb_core_obj->awb_warming_A[2] = ( int32_t )( p_cali_data->cali_awb_warming_ls_a[2] ) << 8;

    p_awb_core_obj->awb_warming_D75[0] = ( int32_t )( p_cali_data->cali_awb_warming_ls_d75[0] ) << 8;
    p_awb_core_obj->awb_warming_D75[1] = ( int32_t )( p_cali_data->cali_awb_warming_ls_d75[1] ) << 8;
    p_awb_core_obj->awb_warming_D75[2] = ( int32_t )( p_cali_data->cali_awb_warming_ls_d75[2] ) << 8;

    p_awb_core_obj->awb_warming_D50[0] = ( int32_t )( p_cali_data->cali_awb_warming_ls_d50[0] ) << 8;
    p_awb_core_obj->awb_warming_D50[1] = ( int32_t )( p_cali_data->cali_awb_warming_ls_d50[1] ) << 8;
    p_awb_core_obj->awb_warming_D50[2] = ( int32_t )( p_cali_data->cali_awb_warming_ls_d50[2] ) << 8;

    // calibration table: AWB Colour preference
    //int16_t AWB_colour_preference[4] = {7500,6000,4700,2800};
    const int16_t *AWB_colour_preference = (int16_t *)p_cali_data->cali_awb_colour_preference;
    int16_t m = 0;
    if ( temperature >= AWB_colour_preference[1] ) {
        //high temp

        //RED
        int awb_red_pref = ( AWB_colour_preference[1] - AWB_colour_preference[0] );
        if ( awb_red_pref == 0 ) {
            awb_red_pref = 1;
        }

        m = ( p_awb_core_obj->awb_warming_D50[0] - p_awb_core_obj->awb_warming_D75[0] ) / awb_red_pref;
        if ( m == 0 ) {
            p_awb_core_obj->awb_warming[0] = p_awb_core_obj->awb_warming_D50[0] >> 8;
        } else {
            p_awb_core_obj->awb_warming[0] = ( m * ( temperature - AWB_colour_preference[0] ) + p_awb_core_obj->awb_warming_D75[0] ) >> 8;
        }

        //GREEN
        int awb_green_pref = ( AWB_colour_preference[1] - AWB_colour_preference[0] );
        if ( awb_green_pref == 0 ) {
            awb_green_pref = 1;
        }
        m = ( p_awb_core_obj->awb_warming_D50[1] - p_awb_core_obj->awb_warming_D75[1] ) / awb_green_pref;
        if ( m == 0 ) {
            p_awb_core_obj->awb_warming[1] = p_awb_core_obj->awb_warming_D50[1] >> 8;
        } else {
            p_awb_core_obj->awb_warming[1] = ( m * ( temperature - AWB_colour_preference[0] ) + p_awb_core_obj->awb_warming_D75[1] ) >> 8;
        }
        //BLUE
        int awb_blue_pref = ( AWB_colour_preference[1] - AWB_colour_preference[0] );
        if ( awb_blue_pref == 0 ) {
            awb_blue_pref = 1;
        }
        m = ( p_awb_core_obj->awb_warming_D50[2] - p_awb_core_obj->awb_warming_D75[2] ) / awb_blue_pref;
        if ( m == 0 ) {
            p_awb_core_obj->awb_warming[2] = p_awb_core_obj->awb_warming_D50[2] >> 8;
        } else {
            p_awb_core_obj->awb_warming[2] = ( m * ( temperature - AWB_colour_preference[0] ) + p_awb_core_obj->awb_warming_D75[2] ) >> 8;
        }
        // printf("1 temp %d r %d g %d b %d \n",(int)temperature,(int)(p_awb_core_obj->awb_warming[0]),(int)(p_awb_core_obj->awb_warming[1]),(int)(p_awb_core_obj->awb_warming[2]) );

    } else if ( temperature <= AWB_colour_preference[2] ) {
        //low temp
        int awb_red_pref = ( AWB_colour_preference[3] - AWB_colour_preference[2] );
        if ( awb_red_pref == 0 ) {
            awb_red_pref = 1;
        }
        m = ( p_awb_core_obj->awb_warming_A[0] - p_awb_core_obj->awb_warming_D50[0] ) / awb_red_pref;
        if ( m == 0 ) {
            p_awb_core_obj->awb_warming[0] = p_awb_core_obj->awb_warming_D50[0] >> 8;
        } else {
            p_awb_core_obj->awb_warming[0] = ( m * ( temperature - AWB_colour_preference[3] ) + p_awb_core_obj->awb_warming_A[0] ) >> 8;
        }
        //GREN
        int awb_green_pref = ( AWB_colour_preference[3] - AWB_colour_preference[2] );
        if ( awb_green_pref == 0 ) {
            awb_green_pref = 1;
        }
        m = ( p_awb_core_obj->awb_warming_A[1] - p_awb_core_obj->awb_warming_D50[1] ) / awb_green_pref;
        if ( m == 0 ) {
            p_awb_core_obj->awb_warming[1] = p_awb_core_obj->awb_warming_D50[1] >> 8;
        } else {
            p_awb_core_obj->awb_warming[1] = ( m * ( temperature - AWB_colour_preference[3] ) + p_awb_core_obj->awb_warming_A[1] ) >> 8;
        }
        //BLUE
        int awb_blue_pref = ( AWB_colour_preference[3] - AWB_colour_preference[2] );
        if ( awb_blue_pref == 0 ) {
            awb_blue_pref = 1;
        }
        m = ( p_awb_core_obj->awb_warming_A[2] - p_awb_core_obj->awb_warming_D50[2] ) / awb_blue_pref;
        if ( m == 0 ) {
            p_awb_core_obj->awb_warming[2] = p_awb_core_obj->awb_warming_D50[2] >> 8;
        } else {
            p_awb_core_obj->awb_warming[2] = ( m * ( temperature - AWB_colour_preference[3] ) + p_awb_core_obj->awb_warming_A[2] ) >> 8;
        }
        // printf("2 temp %d r %d g %d b %d \n",(int)temperature,(int)(p_awb_core_obj->awb_warming[0]),(int)(p_awb_core_obj->awb_warming[1]),(int)(p_awb_core_obj->awb_warming[2]) );
    } else {
        //mid temp
        p_awb_core_obj->awb_warming[0] = p_awb_core_obj->awb_warming_D50[0] >> 8;
        p_awb_core_obj->awb_warming[1] = p_awb_core_obj->awb_warming_D50[1] >> 8;
        p_awb_core_obj->awb_warming[2] = p_awb_core_obj->awb_warming_D50[2] >> 8;
        // printf("3 temp %d r %d g %d b %d \n",(int)temperature,(int)(p_awb_core_obj->awb_warming[0]),(int)(p_awb_core_obj->awb_warming[1]),(int)(p_awb_core_obj->awb_warming[2]) );
    }
}

void *awb_acamera_core_init( uint32_t ctx_id )
{
    awb_acamera_core_obj_t *p_awb_core_obj = NULL;

    if ( ctx_id >= FIRMWARE_CONTEXT_NUMBER ) {
        LOG( LOG_CRIT, "Invalid ctx_id: %d, greater than max: %d.", ctx_id, FIRMWARE_CONTEXT_NUMBER - 1 );
        return NULL;
    }

    p_awb_core_obj = &awb_core_objs[ctx_id];
    memset( p_awb_core_obj, 0, sizeof( *p_awb_core_obj ) );

    p_awb_core_obj->stable_avg_RG = D50_DEFAULT;
    p_awb_core_obj->stable_avg_BG = D50_DEFAULT;
    p_awb_core_obj->avg_GR = 128;
    p_awb_core_obj->avg_GB = 128;

    p_awb_core_obj->max_temp = 10000;
    p_awb_core_obj->min_temp = 2100;
    p_awb_core_obj->max_temp_rg = 256;
    p_awb_core_obj->max_temp_bg = 256;
    p_awb_core_obj->min_temp_rg = 256;
    p_awb_core_obj->min_temp_bg = 256;

    p_awb_core_obj->internal_inited = 0;

    return p_awb_core_obj;
}

int32_t awb_acamera_core_deinit( void *awb_ctx )
{
    return 0;
}


int32_t awb_acamera_core_proc( void *awb_ctx, awb_stats_data_t *stats, awb_input_data_t *input, awb_output_data_t *output )
{
    if ( !awb_ctx || !stats || !input || !input->acamera_input || !output || !output->acamera_output ) {
        LOG( LOG_ERR, "Invalid NULL pointer, %p-%p-%p-%p-%p-%p.", awb_ctx, stats, input, input ? input->acamera_input : NULL, output, output ? output->acamera_output : NULL );
        return -1;
    }

    if ( stats->zones_size > MAX_AWB_ZONES ) {
        LOG( LOG_ERR, "Not supported AWB zones, current size: %d, max: %d.", stats->zones_size, MAX_AWB_ZONES );
        return -2;
    }

    awb_acamera_core_obj_t *p_awb_core_obj = (awb_acamera_core_obj_t *)awb_ctx;
    awb_acamera_input_t *p_acamera_input = (awb_acamera_input_t *)input->acamera_input;
    awb_calibration_data_t *p_cali_data = &( p_acamera_input->cali_data );
    awb_acamera_output_t *p_acamera_output = (awb_acamera_output_t *)output->acamera_output;

    awb_calc_avg_weighted_gr_gb_mesh( p_awb_core_obj, stats, input );

    awb_detect_light_source( p_awb_core_obj );

    awb_calculate_warming_effect( p_awb_core_obj, p_cali_data );

    p_acamera_output->rg_coef = p_awb_core_obj->rg_coef;
    p_acamera_output->bg_coef = p_awb_core_obj->bg_coef;
    p_acamera_output->temperature_detected = p_awb_core_obj->temperature_detected;
    p_acamera_output->p_high = p_awb_core_obj->p_high;
    p_acamera_output->light_source_candidate = p_awb_core_obj->light_source_candidate;
    memcpy( p_acamera_output->awb_warming, p_awb_core_obj->awb_warming, sizeof( p_acamera_output->awb_warming ) );

    return 0;
}
